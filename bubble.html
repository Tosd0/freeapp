<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>独立的交互式气泡样式设计器</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- 引入FileStorageManager相关脚本 -->
    <script src="utils/fileStorageManager.js"></script>
    <script src="utils/imageStorageAPI.js"></script>
    <script src="utils/imageDisplayHelper.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <!-- 中文字体CDN导入 -->
    <link rel='stylesheet' href='https://chinese-fonts-cdn.deno.dev/packages/syst/dist/SourceHanSerifCN/result.css' />
    <link rel='stylesheet' href='https://chinese-fonts-cdn.deno.dev/packages/lxgwwenkaibright/dist/LXGWBright-Regular/result.css' />
    <link rel='stylesheet' href='https://chinese-fonts-cdn.deno.dev/packages/dymh/dist/DouyinSansBold/result.css' />
    <link rel='stylesheet' href='https://chinese-fonts-cdn.deno.dev/packages/hwmct/dist/汇文明朝体/result.css' />
    <link rel='stylesheet' href='https://chinese-fonts-cdn.deno.dev/packages/ToneOZ-Pinyin-Kai/dist/ToneOZ-PinyinW-Kai-Simplified/result.css' />
    <link rel='stylesheet' href='https://chinese-fonts-cdn.deno.dev/packages/hcqyt/dist/ChillRoundFBold/result.css' />
    <link rel='stylesheet' href='https://chinese-fonts-cdn.deno.dev/packages/ysbzt/dist/峄山碑篆体/result.css' />
    <link rel='stylesheet' href='https://chinese-fonts-cdn.deno.dev/packages/yfxy/dist/YuFanXinYu-Medium/result.css' />
    <style>
        body { font-family: 'Inter', sans-serif; }
        input[type="range"]{-webkit-appearance:none;appearance:none;width:100%;height:6px;background:#e2e8f0;border-radius:3px;outline:none;opacity:.7;transition:opacity .2s}
        input[type="range"]:hover{opacity:1}
        input[type="range"]::-webkit-slider-thumb{-webkit-appearance:none;appearance:none;width:20px;height:20px;background:#4f46e5;cursor:pointer;border-radius:50%;border:2px solid #fff;box-shadow:0 0 5px rgba(0,0,0,.2)}
        input[type="color"]{-webkit-appearance:none;-moz-appearance:none;appearance:none;width:40px;height:40px;background-color:transparent;border:none;cursor:pointer}
        input[type="color"]::-webkit-color-swatch{border-radius:50%;border:2px solid #e2e8f0}
        
        .sticker-wrapper {
            position: absolute;
            width: 120px;
            height: auto;
            cursor: grab;
            user-select: none;
            border: 2px solid transparent;
            transition: border-color 0.2s ease;
        }
        .sticker-wrapper.selected {
            border: 2px dashed #4f46e5;
        }
        .sticker-wrapper.dragging {
            cursor: grabbing;
            z-index: 10000 !important;
        }
        .sticker-wrapper.inactive {
            opacity: 0.5;
            pointer-events: none;
            cursor: not-allowed;
        }
        .sticker-image {
            width: 100%;
            height: 100%;
            display: block;
            object-fit: fill; 
        }
        
        .resize-handle {
            position: absolute;
            bottom: -8px;
            right: -8px;
            width: 16px;
            height: 16px;
            background-color: #4f46e5;
            border: 2px solid white;
            border-radius: 4px;
            cursor: se-resize;
            z-index: 1001;
            box-shadow: 0 0 5px rgba(0,0,0,0.2);
        }

        #imageEditorCanvas.dropper-cursor { cursor: crosshair; }
        #stickerLibrary { position: absolute; bottom: 1rem; left: 1rem; z-index: 500; display: flex; flex-wrap: wrap; gap: 0.5rem; background: rgba(255,255,255,0.8); padding: 0.5rem; border-radius: 0.5rem; box-shadow: 0 4px 12px rgba(0,0,0,0.1); backdrop-filter: blur(5px); max-width: 280px; }
        .library-sticker { width: 60px; height: 60px; object-fit: contain; cursor: grab; transition: transform 0.2s; }
        .library-sticker:hover { transform: scale(1.1); }

        .toast {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0,0,0,0.8);
            color: white;
            padding: 12px 24px;
            border-radius: 4px;
            font-size: 14px;
            z-index: 3000;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
        }
        .toast.show {
            opacity: 1;
        }

        .bubble-type-btn {
            transition: all 0.2s ease;
            cursor: pointer;
            border: none;
            outline: none;
        }
        .bubble-type-btn:hover {
            opacity: 0.8;
        }
        
        .sticker-container {
            position: relative;
        }
    </style>
</head>
<body class="bg-slate-100 text-slate-800">

    <div class="container mx-auto p-4 md:p-8">
        <header class="text-center mb-8">
            <h1 class="text-3xl md:text-4xl font-bold text-slate-900">交互式气泡样式设计器</h1>
            <p class="text-slate-500 mt-2">单击选中贴图可调整图层，双击可删除。</p>
        </header>

        <main class="grid grid-cols-1 lg:grid-cols-3 gap-8">
            <div class="lg:col-span-2 bg-white rounded-2xl shadow-lg p-6 flex flex-col min-h-[400px] lg:min-h-[600px] overflow-hidden">
                <div class="flex-1 flex flex-col">
                    <!-- 气泡类型选择控件 -->
                    <div class="mb-4 text-center">
                        <div class="inline-flex items-center bg-slate-200 rounded-full p-1">
                            <button id="bubbleTypeSelf" class="bubble-type-btn bg-white text-indigo-600 rounded-full px-4 py-2 text-sm font-semibold">我的气泡</button>
                            <button id="bubbleTypeOthers" class="bubble-type-btn text-slate-600 rounded-full px-4 py-2 text-sm font-semibold">对方气泡</button>
                        </div>
                    </div>
                    
                    <!-- 双气泡预览区域 -->
                    <div id="previewContainer" class="relative flex-1 flex flex-col justify-center space-y-4 p-4">
                        <!-- 我的气泡 -->
                        <div class="flex justify-end">
                            <div id="previewBubbleSelf" class="max-w-[70%] w-auto min-w-[80px] text-left text-lg leading-relaxed transition-all duration-200 relative" style="padding: 12px 18px; border: 1px solid rgba(0,0,0,0.05); background-color: rgb(135, 206, 250); border-radius: 12px;">
                                <span id="bubbleTextContentSelf" style="position: relative; z-index: 10; color: rgb(255, 255, 255);">
                                    这是我发的消息
                                </span>
                                <div id="stickerLibrarySelf" class="sticker-container"></div>
                            </div>
                        </div>
                        
                        <!-- 对方气泡 -->
                        <div class="flex justify-start">
                            <div id="previewBubbleOthers" class="max-w-[70%] w-auto min-w-[80px] text-left text-lg leading-relaxed transition-all duration-200 relative" style="padding: 12px 18px; border: 1px solid rgba(0,0,0,0.05); background-color: rgb(255, 255, 255); border-radius: 12px;">
                                <span id="bubbleTextContentOthers" style="position: relative; z-index: 10; color: rgb(51, 51, 51);">
                                    这是对方发的消息
                                </span>
                                <div id="stickerLibraryOthers" class="sticker-container"></div>
                            </div>
                        </div>
                        
                        <div id="stickerLibrary"></div>
                    </div>
                </div>
            </div>

            <div class="lg:col-span-1 bg-white rounded-2xl shadow-lg p-6 space-y-6 overflow-y-auto max-h-[calc(100vh-100px)]">
                <div>
                    <h3 class="font-semibold text-lg mb-3">贴图装饰 (Stickers)</h3>
                    <button id="manageStickersBtn" class="w-full bg-indigo-600 text-white text-center font-medium py-2 px-4 rounded-lg cursor-pointer hover:bg-indigo-700 transition-colors block">管理贴图库</button>
                </div>
                <div id="layerControlPanel">
                    <h3 class="font-semibold text-lg mb-3">图层顺序</h3>
                    <div class="flex gap-2">
                        <button id="sendToBackBtn" class="w-full bg-slate-500 text-white font-medium py-2 rounded-lg hover:bg-slate-600 disabled:opacity-50 disabled:cursor-not-allowed" disabled>置于底层</button>
                        <button id="bringToFrontBtn" class="w-full bg-slate-500 text-white font-medium py-2 rounded-lg hover:bg-slate-600 disabled:opacity-50 disabled:cursor-not-allowed" disabled>置于顶层</button>
                    </div>
                </div>
                <div>
                    <h3 class="font-semibold text-lg mb-3">气泡基础样式</h3>
                    <div class="space-y-4">
                        <div><label for="borderWidth" class="flex justify-between text-sm font-medium text-slate-700">边框宽度 <span id="borderWidthValue">1px</span></label><input type="range" id="borderWidth" min="0" max="50" value="1" class="mt-1"></div>
                        <div><label for="borderColor" class="flex justify-between items-center text-sm font-medium text-slate-700">边框颜色 <input type="color" id="borderColor" value="#4f46e5"></label></div>
                        <!-- 【新增】文本颜色控制器 -->
                        <div><label for="textColor" class="flex justify-between items-center text-sm font-medium text-slate-700">文本颜色 <input type="color" id="textColor" value="#333333"></label></div>
                        <!-- 【新增】字体选择器 -->
                        <div>
                            <label for="fontFamily" class="text-sm font-medium text-slate-700">字体选择</label>
                            <select id="fontFamily" class="w-full mt-1 p-2 border border-slate-300 rounded-lg focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500">
                                <option value="Inter">默认字体 (Inter)</option>
                                <option value="Source Han Serif CN VF">思源宋体</option>
                                <option value="LXGW WenKai">霞鹜文楷</option>
                                <option value="Douyin Sans">抖音美好体</option>
                                <option value="Huiwen-mincho">汇文明朝体</option>
                                <option value="ToneOZ-PinyinW-Kai-Simplified">拼音鼎楷</option>
                                <option value="寒蝉全圆体 Bold">寒蝉全圆体</option>
                                <option value="峄山碑篆体">峄山碑篆体</option>
                                <option value="YuFanXinYu-Medium">余繁新语</option>
                            </select>
                        </div>
                        <div><label for="borderRadius" class="flex justify-between text-sm font-medium text-slate-700">圆角半径 <span id="borderRadiusValue">12px</span></label><input type="range" id="borderRadius" min="0" max="100" value="12" class="mt-1"></div>
                        <div class="flex items-center justify-between"><span class="text-sm font-medium text-slate-700">背景类型</span><div class="flex items-center bg-slate-200 rounded-full p-1"><button id="bgTypeSolid" class="bg-type-btn bg-white text-indigo-600 rounded-full px-3 py-1 text-sm font-semibold">纯色</button><button id="bgTypeGradient" class="bg-type-btn text-slate-600 rounded-full px-3 py-1 text-sm font-semibold">渐变</button></div></div>
                        <div id="solidBgControls">
                             <div class="flex items-center justify-between"><label for="bgColor" class="text-sm font-medium text-slate-700">背景颜色</label><input type="color" id="bgColor" value="#ffffff"></div>
                            <div><label for="bgOpacity" class="flex justify-between text-sm font-medium text-slate-700">透明度 <span id="bgOpacityValue">100%</span></label><input type="range" id="bgOpacity" min="0" max="1" step="0.01" value="1" class="mt-1"></div>
                        </div>
                        <div id="gradientBgControls" class="hidden space-y-4">
                            <div class="flex items-center justify-between"><label for="gradientColor1" class="text-sm font-medium text-slate-700">颜色 1</label><input type="color" id="gradientColor1" value="#a5b4fc"></div>
                            <div class="flex items-center justify-between"><label for="gradientColor2" class="text-sm font-medium text-slate-700">颜色 2</label><input type="color" id="gradientColor2" value="#e0e7ff"></div>
                            <div><label for="gradientAngle" class="flex justify-between text-sm font-medium text-slate-700">渐变角度 <span id="gradientAngleValue">145deg</span></label><input type="range" id="gradientAngle" min="0" max="360" value="145" class="mt-1"></div>
                        </div>
                    </div>
                </div>
                <div>
                    <h3 class="font-semibold text-lg mb-3">内容与代码</h3>
                    <div class="space-y-4">
                        <div><label for="bubbleText" class="text-sm font-medium text-slate-700">气泡文本</label><textarea id="bubbleText" rows="3" class="w-full mt-1 p-2 border border-slate-300 rounded-lg focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500">这里是你的气泡预览区域。点击"管理贴图库"开始创作！</textarea></div>
                        <button id="generateCodeBtn" class="w-full bg-emerald-500 text-white font-medium py-2 px-4 rounded-lg hover:bg-emerald-600 transition-colors">应用此样式到聊天</button>
                        <button id="resetToDefaultBtn" class="w-full bg-slate-500 text-white font-medium py-2 px-4 rounded-lg hover:bg-slate-600 transition-colors">恢复默认气泡</button>
                    </div>
                </div>
            </div>
        </main>
    </div>

    <!-- 贴图管理器 Modal -->
    <div id="imageProcessorModal" class="fixed inset-0 bg-black bg-opacity-50 z-[1000] hidden flex items-center justify-center p-4">
        <div class="w-full h-full max-w-6xl max-h-[90vh] bg-white rounded-2xl shadow-2xl flex flex-col md:flex-row">
            <div class="w-full md:w-1/3 flex flex-col border-r border-slate-200">
                <div class="p-4 border-b border-slate-200">
                    <h3 class="font-bold text-xl">贴图库</h3>
                    <p class="text-sm text-slate-500">在这里管理和编辑你的贴图。</p>
                </div>
                <div id="stickerGallery" class="flex-1 p-4 overflow-y-auto grid grid-cols-3 sm:grid-cols-4 gap-4">
                </div>
                <div class="p-4 border-t border-slate-200 space-y-2">
                    <label for="galleryStickerUpload" class="w-full bg-indigo-600 text-white text-center font-medium py-2 px-4 rounded-lg cursor-pointer hover:bg-indigo-700 transition-colors block">上传新贴图</label>
                    <input type="file" id="galleryStickerUpload" accept="image/*" multiple class="hidden">
                    <p class="text-xs text-slate-500 mt-2 text-center">提示：移除背景功能不支持GIF动图。请先使用外部工具处理GIF，再上传。</p>
                    <button id="closeProcessorBtn" class="w-full bg-slate-600 text-white font-medium py-2 rounded-lg hover:bg-slate-700 mt-2">完成并关闭</button>
                </div>
            </div>
            <div class="w-full md:w-2/3 flex flex-col">
                <div id="imageEditor" class="flex-1 flex items-center justify-center bg-slate-100 p-4 relative">
                    <canvas id="imageEditorCanvas" class="max-w-full max-h-full shadow-lg"></canvas>
                    <div id="editorPlaceholder" class="text-slate-500">从左侧选择一张图片进行编辑</div>
                </div>
                <div id="editorControls" class="p-4 border-t border-slate-200 bg-white space-y-4 hidden">
                    <button id="removeBgBtn" class="w-full bg-indigo-500 text-white font-medium py-2 px-4 rounded-lg hover:bg-indigo-600">💧 移除背景</button>
                    <div>
                        <label for="tolerance" class="flex justify-between text-sm font-medium text-slate-700">容差 <span id="toleranceValue">20</span></label>
                        <input type="range" id="tolerance" min="0" max="150" value="20" class="mt-1">
                    </div>
                    <div class="flex gap-2">
                        <button id="saveChangesBtn" class="w-full bg-emerald-500 text-white font-medium py-2 rounded-lg hover:bg-emerald-600">保存更改</button>
                        <button id="resetStickerBtn" class="w-full bg-gray-500 text-white font-medium py-2 rounded-lg hover:bg-gray-600">重置图片</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="toast" id="toast"></div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const previewContainer = document.getElementById('previewContainer');
            const previewBubbleSelf = document.getElementById('previewBubbleSelf');
            const previewBubbleOthers = document.getElementById('previewBubbleOthers');
            const bubbleTextContentSelf = document.getElementById('bubbleTextContentSelf');
            const bubbleTextContentOthers = document.getElementById('bubbleTextContentOthers');
            const stickerLibraryContainer = document.getElementById('stickerLibrary');
            const imageProcessorModal = document.getElementById('imageProcessorModal');
            const stickerGallery = document.getElementById('stickerGallery');
            const imageEditorCanvas = document.getElementById('imageEditorCanvas');
            const editorControls = document.getElementById('editorControls');
            const editorPlaceholder = document.getElementById('editorPlaceholder');
            const ctx = imageEditorCanvas.getContext('2d');
            
            const controls = {
                manageStickersBtn: document.getElementById('manageStickersBtn'),
                closeProcessorBtn: document.getElementById('closeProcessorBtn'),
                galleryStickerUpload: document.getElementById('galleryStickerUpload'),
                removeBgBtn: document.getElementById('removeBgBtn'),
                tolerance: document.getElementById('tolerance'),
                toleranceValue: document.getElementById('toleranceValue'),
                saveChangesBtn: document.getElementById('saveChangesBtn'),
                resetStickerBtn: document.getElementById('resetStickerBtn'),
                sendToBackBtn: document.getElementById('sendToBackBtn'),
                bringToFrontBtn: document.getElementById('bringToFrontBtn'),
                borderWidth: document.getElementById('borderWidth'),
                borderWidthValue: document.getElementById('borderWidthValue'),
                borderColor: document.getElementById('borderColor'),
                textColor: document.getElementById('textColor'),
                fontFamily: document.getElementById('fontFamily'),
                borderRadius: document.getElementById('borderRadius'),
                borderRadiusValue: document.getElementById('borderRadiusValue'),
                bgTypeSolid: document.getElementById('bgTypeSolid'),
                bgTypeGradient: document.getElementById('bgTypeGradient'),
                solidBgControls: document.getElementById('solidBgControls'),
                gradientBgControls: document.getElementById('gradientBgControls'),
                bgColor: document.getElementById('bgColor'),
                bgOpacity: document.getElementById('bgOpacity'),
                bgOpacityValue: document.getElementById('bgOpacityValue'),
                gradientColor1: document.getElementById('gradientColor1'),
                gradientColor2: document.getElementById('gradientColor2'),
                gradientAngle: document.getElementById('gradientAngle'),
                gradientAngleValue: document.getElementById('gradientAngleValue'),
                bubbleText: document.getElementById('bubbleText'),
                generateCodeBtn: document.getElementById('generateCodeBtn'),
                resetToDefaultBtn: document.getElementById('resetToDefaultBtn'),
                bubbleTypeSelf: document.getElementById('bubbleTypeSelf'),
                bubbleTypeOthers: document.getElementById('bubbleTypeOthers'),
            };

            const DB_NAME = 'WhaleLLTDB';
            const DB_VERSION = 11;
            let db = null;
            let fileStorageManager = null;
            let stickerLibrary = [];
            let currentEditingStickerId = null;
            let targetColor = null;
            let currentBgType = 'solid';
            let selectedStickerWrapper = null;
            let zIndexCounter = 11;
            let currentBubbleType = 'self'; // 'self' 或 'others'

            function showToast(message) {
                const toast = document.getElementById('toast');
                toast.textContent = message;
                toast.classList.add('show');
                setTimeout(() => toast.classList.remove('show'), 2000);
            }

            async function initStorageSystem() {
                try {
                    // 直接使用主应用的现有数据库连接
                    if (window.parent && window.parent.db && window.parent.isIndexedDBReady) {
                        db = window.parent.db;
                        console.log('使用主应用的现有数据库连接，版本:', db.version);
                    } else {
                        // 如果没有父窗口连接，创建独立连接
                        fileStorageManager = new FileStorageManager();
                        await fileStorageManager.init();
                        db = fileStorageManager.db;
                        console.log('创建独立数据库连接成功');
                    }
                    
                    // 如果还没有fileStorageManager，创建一个并使用现有连接
                    if (!fileStorageManager) {
                        fileStorageManager = new FileStorageManager();
                        fileStorageManager.db = db;
                        console.log('FileStorageManager初始化成功');
                    }
                    
                    return true;
                } catch (error) {
                    console.error('存储系统初始化失败:', error);
                    showToast('存储系统初始化失败，将使用内存存储');
                    return false;
                }
            }

            async function saveStickerLibraryToStorage() {
                try {
                    if (!db) {
                        console.warn('数据库连接不可用，跳过保存');
                        return;
                    }
                    
                    // 使用现有数据库的 themeConfig 表保存贴图库
                    const transaction = db.transaction(['themeConfig'], 'readwrite');
                    const store = transaction.objectStore('themeConfig');
                    
                    // 保存整个贴图库作为一个主题配置
                    const libraryData = {
                        type: 'bubbleStickers',
                        data: stickerLibrary,
                        lastModified: new Date().toISOString()
                    };
                    
                    store.put(libraryData);
                    
                    transaction.oncomplete = () => {
                        console.log('贴图库保存到 themeConfig 成功');
                    };
                    
                    transaction.onerror = () => {
                        console.error('贴图库保存失败:', transaction.error);
                        showToast('保存失败：' + transaction.error.message);
                    };
                } catch (e) {
                    console.error("无法保存贴图库:", e);
                    showToast("错误：无法保存贴图库。");
                }
            }

            async function loadStickerLibraryFromStorage() {
                try {
                    if (!db) {
                        console.warn('数据库连接不可用，使用空贴图库');
                        stickerLibrary = [];
                        return;
                    }
                    
                    return new Promise((resolve) => {
                        const transaction = db.transaction(['themeConfig'], 'readonly');
                        const store = transaction.objectStore('themeConfig');
                        const request = store.get('bubbleStickers');
                        
                        request.onsuccess = () => {
                            const result = request.result;
                            if (result && result.data) {
                                stickerLibrary = result.data;
                                console.log('贴图库从 themeConfig 加载成功，共', stickerLibrary.length, '个贴图');
                            } else {
                                stickerLibrary = [];
                                console.log('未找到已保存的贴图库，使用空库');
                            }
                            resolve();
                        };
                        
                        request.onerror = () => {
                            console.error('加载贴图库失败:', request.error);
                            stickerLibrary = [];
                            resolve(); // 即使失败也要继续
                        };
                    });
                } catch (e) {
                    console.error("无法加载贴图库:", e);
                    stickerLibrary = [];
                }
            }

            function updateBubbleStyle() {
                const borderWidth = controls.borderWidth.value;
                const borderRadius = controls.borderRadius.value;
                
                // 获取当前编辑的气泡元素
                const currentBubble = currentBubbleType === 'self' ? previewBubbleSelf : previewBubbleOthers;
                const currentTextContent = currentBubbleType === 'self' ? bubbleTextContentSelf : bubbleTextContentOthers;
                
                currentBubble.style.borderWidth = `${borderWidth}px`;
                currentBubble.style.borderColor = controls.borderColor.value;
                currentBubble.style.borderRadius = `${borderRadius}px`;
                
                // 更新文本颜色
                currentTextContent.style.color = controls.textColor.value;
                
                // 更新字体
                currentTextContent.style.fontFamily = controls.fontFamily.value;

                if (currentBgType === 'solid') {
                    const color = controls.bgColor.value;
                    const opacity = controls.bgOpacity.value;
                    const r = parseInt(color.slice(1, 3), 16), g = parseInt(color.slice(3, 5), 16), b = parseInt(color.slice(5, 7), 16);
                    currentBubble.style.backgroundColor = `rgba(${r}, ${g}, ${b}, ${opacity})`;
                } else {
                    const color1 = controls.gradientColor1.value, color2 = controls.gradientColor2.value, angle = controls.gradientAngle.value;
                    currentBubble.style.background = `linear-gradient(${angle}deg, ${color1}, ${color2})`;
                }
                controls.borderWidthValue.textContent = `${borderWidth}px`;
                controls.borderRadiusValue.textContent = `${borderRadius}px`;
                controls.bgOpacityValue.textContent = `${Math.round(controls.bgOpacity.value * 100)}%`;
                controls.gradientAngleValue.textContent = `${controls.gradientAngle.value}deg`;
            }

            // 获取当前气泡类型
            function getCurrentBubbleType() {
                return currentBubbleType || 'self';
            }

            // 更新所有贴纸的交互状态
            function updateStickersInteractionState() {
                // 更新自己气泡中的贴纸状态
                previewBubbleSelf.querySelectorAll('.sticker-wrapper').forEach(wrapper => {
                    if (currentBubbleType === 'self') {
                        wrapper.classList.remove('inactive');
                    } else {
                        wrapper.classList.add('inactive');
                    }
                });

                // 更新对方气泡中的贴纸状态
                previewBubbleOthers.querySelectorAll('.sticker-wrapper').forEach(wrapper => {
                    if (currentBubbleType === 'others') {
                        wrapper.classList.remove('inactive');
                    } else {
                        wrapper.classList.add('inactive');
                    }
                });
            }

            // 切换气泡类型
            async function switchBubbleType(type) {
                currentBubbleType = type;
                
                // 更新按钮状态
                if (type === 'self') {
                    controls.bubbleTypeSelf.classList.add('bg-white', 'text-indigo-600');
                    controls.bubbleTypeSelf.classList.remove('text-slate-600');
                    controls.bubbleTypeOthers.classList.remove('bg-white', 'text-indigo-600');
                    controls.bubbleTypeOthers.classList.add('text-slate-600');
                } else {
                    controls.bubbleTypeOthers.classList.add('bg-white', 'text-indigo-600');
                    controls.bubbleTypeOthers.classList.remove('text-slate-600');
                    controls.bubbleTypeSelf.classList.remove('bg-white', 'text-indigo-600');
                    controls.bubbleTypeSelf.classList.add('text-slate-600');
                }
                
                // 加载对应类型的样式设置
                await loadBubbleTypeSettings(type);
                
                // 更新贴纸交互状态
                updateStickersInteractionState();
                
                showToast(`已切换到${type === 'self' ? '我的气泡' : '对方气泡'}编辑模式`);
            }

            // 加载指定气泡类型的设置
            async function loadBubbleTypeSettings(type) {
                const targetBubble = type === 'self' ? previewBubbleSelf : previewBubbleOthers;
                const targetTextContent = type === 'self' ? bubbleTextContentSelf : bubbleTextContentOthers;
                
                // 首先尝试从保存的配置中加载
                const styleKey = type === 'self' ? 'bubbleStyleSelf' : 'bubbleStyle';
                const savedConfig = await loadBubbleStyleConfig(styleKey);
                
                if (savedConfig) {
                    // 如果有保存的配置，应用到控件
                    console.log(`加载${type === 'self' ? '我的' : '对方的'}气泡保存配置`);
                    
                    // 应用基础样式到控件
                    controls.borderWidth.value = savedConfig.borderWidth || 1;
                    controls.borderColor.value = savedConfig.borderColor || '#4f46e5';
                    controls.borderRadius.value = savedConfig.borderRadius || 12;
                    controls.textColor.value = savedConfig.textColor || '#333333';
                    controls.fontFamily.value = savedConfig.fontFamily || 'Inter';
                    
                    // 应用背景样式到控件
                    currentBgType = savedConfig.backgroundType || 'solid';
                    controls.bgColor.value = savedConfig.backgroundColor || '#ffffff';
                    controls.bgOpacity.value = savedConfig.backgroundOpacity || 1;
                    controls.gradientColor1.value = savedConfig.gradientColor1 || '#a5b4fc';
                    controls.gradientColor2.value = savedConfig.gradientColor2 || '#e0e7ff';
                    controls.gradientAngle.value = savedConfig.gradientAngle || 145;
                    
                    // 切换背景类型UI
                    if (currentBgType === 'gradient') {
                        controls.bgTypeGradient.click();
                    } else {
                        controls.bgTypeSolid.click();
                    }
                    
                    // 文本内容始终使用默认值，不从配置中加载
                    const defaultText = type === 'self' ? '这是我发的消息' : '这是对方发的消息';
                    controls.bubbleText.value = defaultText;
                    targetTextContent.textContent = defaultText;
                    
                } else {
                    // 如果没有保存的配置，使用默认值
                    console.log(`使用${type === 'self' ? '我的' : '对方的'}气泡默认配置`);
                    
                    // 设置默认值
                    controls.borderWidth.value = 1;
                    controls.borderColor.value = '#4f46e5';
                    controls.borderRadius.value = 12;
                    controls.textColor.value = type === 'self' ? '#ffffff' : '#333333';
                    controls.fontFamily.value = 'Inter';
                    
                    currentBgType = 'solid';
                    controls.bgColor.value = type === 'self' ? '#87CEEB' : '#ffffff';
                    controls.bgOpacity.value = 1;
                    controls.gradientColor1.value = '#a5b4fc';
                    controls.gradientColor2.value = '#e0e7ff';
                    controls.gradientAngle.value = 145;
                    
                    controls.bgTypeSolid.click();
                    
                    // 文本内容始终使用默认值
                    const defaultText = type === 'self' ? '这是我发的消息' : '这是对方发的消息';
                    controls.bubbleText.value = defaultText;
                    targetTextContent.textContent = defaultText;
                }
                
                // 更新样式显示
                updateBubbleStyle();
            }

            function openProcessor() { 
                imageProcessorModal.style.display = 'flex'; 
                populateStickerGallery().catch(error => console.error('填充贴图库失败:', error)); 
            }
            function closeProcessor() { 
                imageProcessorModal.style.display = 'none'; 
                renderStickerLibrary().catch(error => console.error('渲染贴图库失败:', error)); 
            }

            async function handleStickerUpload(event) {
                const files = event.target.files;
                if (!files || files.length === 0) return;
                
                try {
                    showToast('正在上传贴图...');
                    
                    for (const file of files) {
                        if (!file.type.startsWith('image/')) {
                            console.warn('跳过非图片文件:', file.name);
                            continue;
                        }
                        
                        // 生成唯一ID
                        const stickerId = 'sticker_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                        
                        if (fileStorageManager) {
                            // 直接使用FileStorageManager存储文件到IndexedDB
                            try {
                                const storeResult = await fileStorageManager.storeFile(file, {
                                    category: 'bubble_sticker',
                                    originalName: file.name
                                });
                                
                                // storeResult 是一个对象 {fileId, type, size}，我们需要 fileId
                                const actualFileId = storeResult.fileId;
                                console.log('存储结果:', storeResult, '实际fileId:', actualFileId, '类型:', typeof actualFileId);
                                
                                // 创建文件引用
                                await fileStorageManager.createFileReference(
                                    actualFileId,
                                    'bubble_sticker',
                                    stickerId,
                                    {
                                        originalName: file.name,
                                        fileType: storeResult.type,
                                        fileSize: storeResult.size
                                    }
                                );
                                
                                // 创建贴图记录（保存fileId字符串，用于获取fileSystem引用）
                                const newSticker = {
                                    id: stickerId,
                                    fileId: actualFileId,
                                    originalName: file.name,
                                    fileType: storeResult.type,
                                    fileSize: storeResult.size,
                                    createdAt: new Date().toISOString()
                                };
                                
                                stickerLibrary.push(newSticker);
                                console.log('贴图存储成功(IndexedDB+FileSystem):', newSticker);
                                
                            } catch (error) {
                                console.error('FileStorageManager存储失败，回退到base64:', error);
                                // 回退到base64存储
                                await handleStickerUploadFallback(file, stickerId);
                            }
                        } else {
                            // 回退到base64存储
                            await handleStickerUploadFallback(file, stickerId);
                        }
                    }
                    
                    await saveStickerLibraryToStorage();
                    populateStickerGallery().catch(error => console.error('填充贴图库失败:', error));
                    showToast(`成功上传 ${files.length} 个贴图`);
                    
                } catch (error) {
                    console.error('贴图上传失败:', error);
                    showToast('上传失败: ' + error.message);
                }
                
                event.target.value = '';
            }
            
            // 回退到base64存储的函数
            async function handleStickerUploadFallback(file, stickerId) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        const newSticker = {
                            id: stickerId,
                            baseSrc: e.target.result,
                            currentSrc: e.target.result,
                            originalName: file.name,
                            fileType: file.type,
                            fileSize: file.size,
                            createdAt: new Date().toISOString(),
                            isBase64: true // 标记为base64存储
                        };
                        stickerLibrary.push(newSticker);
                        console.log('贴图base64存储成功:', newSticker);
                        resolve();
                    };
                    reader.onerror = () => reject(reader.error);
                    reader.readAsDataURL(file);
                });
            }
            
            async function populateStickerGallery() {
                stickerGallery.innerHTML = '';
                
                for (const sticker of stickerLibrary) {
                    const container = document.createElement('div');
                    container.className = 'relative group';
                    
                    const img = document.createElement('img');
                    img.className = 'w-full h-full object-contain bg-slate-200 rounded-md cursor-pointer hover:ring-2 ring-indigo-500';
                    img.dataset.id = sticker.id;
                    img.addEventListener('click', () => selectStickerForEditing(sticker.id));
                    
                    // 获取图片URL
                    try {
                        let imageUrl;
                        if (sticker.fileId && fileStorageManager) {
                            // 使用FileStorageManager获取fileSystem引用URL
                            console.log('尝试获取图片URL，fileId:', sticker.fileId, '类型:', typeof sticker.fileId);
                            imageUrl = await fileStorageManager.createFileURL(sticker.fileId);
                        } else if (sticker.currentSrc || sticker.baseSrc) {
                            // 回退到base64
                            imageUrl = sticker.currentSrc || sticker.baseSrc;
                        } else {
                            console.warn('贴图无有效的图片源:', sticker);
                            imageUrl = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCIgdmlld0JveD0iMCAwIDEwMCAxMDAiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHJlY3Qgd2lkdGg9IjEwMCIgaGVpZ2h0PSIxMDAiIGZpbGw9IiNmNWY1ZjUiLz48dGV4dCB4PSI1MCIgeT0iNTUiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGZvbnQtc2l6ZT0iMTQiIGZpbGw9IiM5OTk5OTkiPu+8n++8s++8ne+8kO+8hu+8l++8jjwvdGV4dD48L3N2Zz4='; // 占位符SVG
                        }
                        
                        img.src = imageUrl;
                    } catch (error) {
                        console.error('获取贴图URL失败:', error);
                        img.src = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCIgdmlld0JveD0iMCAwIDEwMCAxMDAiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHJlY3Qgd2lkdGg9IjEwMCIgaGVpZ2h0PSIxMDAiIGZpbGw9IiNmNWY1ZjUiLz48dGV4dCB4PSI1MCIgeT0iNTUiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGZvbnQtc2l6ZT0iMTQiIGZpbGw9IiM5OTk5OTkiPu+8n++8s++8ne+8kO+8hu+8l++8jjwvdGV4dD48L3N2Zz4=';
                    }
                    
                    const deleteBtn = document.createElement('button');
                    deleteBtn.innerHTML = '&times;';
                    deleteBtn.className = 'absolute top-1 right-1 bg-red-500 text-white rounded-full w-5 h-5 flex items-center justify-center text-xs opacity-0 group-hover:opacity-100 transition-opacity z-10';
                    deleteBtn.addEventListener('click', async (e) => { 
                        e.stopPropagation(); 
                        if (confirm('确定要删除这个贴纸吗？此操作将永久删除文件且无法恢复。')) {
                            await deleteSticker(sticker.id); 
                        }
                    });
                    
                    container.appendChild(img);
                    container.appendChild(deleteBtn);
                    stickerGallery.appendChild(container);
                }
            }
            
            async function deleteSticker(id) {
                // 首先获取要删除的贴纸信息，以便清理文件存储
                const stickerToDelete = stickerLibrary.find(s => s.id === id);
                
                if (stickerToDelete && stickerToDelete.fileId && fileStorageManager) {
                    try {
                        console.log('清理贴纸文件存储，stickerId:', id, 'fileId:', stickerToDelete.fileId);
                        
                        // 删除文件引用
                        await fileStorageManager.deleteFileReference('bubble_sticker_' + id);
                        console.log('文件引用删除成功');
                        
                        // 删除实际文件（FileStorageManager会检查是否还有其他引用）
                        await fileStorageManager.deleteFile(stickerToDelete.fileId);
                        console.log('文件存储删除成功');
                        
                    } catch (error) {
                        console.error('清理文件存储失败:', error);
                        // 即使文件存储清理失败，也继续删除贴纸记录
                    }
                }
                
                // 从贴纸库中移除
                stickerLibrary = stickerLibrary.filter(s => s.id != id);
                saveStickerLibraryToStorage();
                populateStickerGallery().catch(error => console.error('填充贴图库失败:', error));
                
                if (currentEditingStickerId == id) {
                    currentEditingStickerId = null;
                    editorPlaceholder.classList.remove('hidden');
                    editorControls.classList.add('hidden');
                    ctx.clearRect(0, 0, imageEditorCanvas.width, imageEditorCanvas.height);
                }
            }

            async function renderStickerLibrary() {
                stickerLibraryContainer.innerHTML = '';
                
                for (const sticker of stickerLibrary) {
                    const img = document.createElement('img');
                    img.className = 'library-sticker';
                    img.dataset.id = sticker.id;
                    
                    // 获取图片URL
                    try {
                        let imageUrl;
                        if (sticker.fileId && fileStorageManager) {
                            imageUrl = await fileStorageManager.createFileURL(sticker.fileId);
                        } else if (sticker.currentSrc || sticker.baseSrc) {
                            imageUrl = sticker.currentSrc || sticker.baseSrc;
                        } else {
                            console.warn('贴图无有效的图片源:', sticker);
                            continue; // 跳过无效贴图
                        }
                        
                        img.src = imageUrl;
                    } catch (error) {
                        console.error('获取贴图URL失败:', error);
                        continue; // 跳过失败的贴图
                    }
                    
                    makeLibraryStickerDraggable(img);
                    stickerLibraryContainer.appendChild(img);
                }
            }

            function selectStickerForEditing(id) {
                currentEditingStickerId = id;
                const sticker = stickerLibrary.find(s => s.id == id);
                if (!sticker) return;
                editorPlaceholder.classList.add('hidden');
                editorControls.classList.remove('hidden');
                const img = new Image();
                img.crossOrigin = "Anonymous";
                img.src = sticker.currentSrc;
                img.onload = () => {
                    imageEditorCanvas.width = img.naturalWidth;
                    imageEditorCanvas.height = img.naturalHeight;
                    ctx.clearRect(0, 0, imageEditorCanvas.width, imageEditorCanvas.height);
                    ctx.drawImage(img, 0, 0);
                }
            }
            
            function processImage(colorToRemove, tolerance) {
                const sticker = stickerLibrary.find(s => s.id == currentEditingStickerId);
                if (!sticker) return;
                const img = new Image();
                img.crossOrigin = "Anonymous";
                img.src = sticker.baseSrc;
                img.onload = () => {
                    imageEditorCanvas.width = img.naturalWidth;
                    imageEditorCanvas.height = img.naturalHeight;
                    ctx.drawImage(img, 0, 0);
                    const imageData = ctx.getImageData(0, 0, imageEditorCanvas.width, imageEditorCanvas.height);
                    const data = imageData.data;
                    const [tr, tg, tb] = colorToRemove;
                    for (let i = 0; i < data.length; i += 4) {
                        const r = data[i], g = data[i + 1], b = data[i + 2];
                        const distance = Math.sqrt(Math.pow(r - tr, 2) + Math.pow(g - tg, 2) + Math.pow(b - tb, 2));
                        if (distance < tolerance) { data[i + 3] = 0; }
                    }
                    ctx.putImageData(imageData, 0, 0);
                };
            }

            // 获取贴图URL的辅助函数
            async function getStickerImageURL(sticker) {
                try {
                    if (sticker.fileId && fileStorageManager) {
                        return await fileStorageManager.createFileURL(sticker.fileId);
                    } else if (sticker.currentSrc || sticker.baseSrc) {
                        return sticker.currentSrc || sticker.baseSrc;
                    } else {
                        console.warn('贴图无有效的图片源:', sticker);
                        return null;
                    }
                } catch (error) {
                    console.error('获取贴图URL失败:', error);
                    return sticker.currentSrc || sticker.baseSrc || null;
                }
            }

            function makeLibraryStickerDraggable(element) {
                element.addEventListener('mousedown', async (e) => {
                    e.preventDefault();
                    const stickerData = stickerLibrary.find(s => s.id == element.dataset.id);
                    if (!stickerData) return;
                    
                    const wrapper = document.createElement('div');
                    wrapper.className = 'sticker-wrapper';
                    wrapper.dataset.id = stickerData.id;
                    wrapper.style.zIndex = zIndexCounter++; 
                    
                    const newSticker = document.createElement('img');
                    newSticker.className = 'sticker-image';
                    
                    // 异步获取图片URL
                    const imageUrl = await getStickerImageURL(stickerData);
                    if (!imageUrl) {
                        console.error('无法获取贴图URL，跳过创建');
                        return;
                    }
                    newSticker.src = imageUrl;
                    
                    const resizeHandle = document.createElement('div');
                    resizeHandle.className = 'resize-handle';
                    
                    wrapper.appendChild(newSticker);
                    wrapper.appendChild(resizeHandle);
                    
                    // 根据当前选择的气泡类型添加贴图
                    const targetBubble = currentBubbleType === 'self' ? previewBubbleSelf : previewBubbleOthers;
                    targetBubble.appendChild(wrapper);

                    const bubbleRect = targetBubble.getBoundingClientRect();
                    const initialWidth = 120;
                    wrapper.style.width = `${initialWidth}px`;
                    const tempImg = new Image();
                    tempImg.src = imageUrl;
                    tempImg.onload = () => {
                        const aspectRatio = tempImg.naturalHeight / tempImg.naturalWidth;
                        wrapper.style.height = `${initialWidth * aspectRatio}px`;
                        wrapper.style.left = `${(bubbleRect.width - wrapper.offsetWidth) / 2}px`;
                        wrapper.style.top = `${(bubbleRect.height - wrapper.offsetHeight) / 2}px`;
                    };
                    
                    makePlacedStickerInteractive(wrapper);
                    
                    // 添加贴纸后更新交互状态
                    updateStickersInteractionState();
                });
            }
            
            function makePlacedStickerInteractive(wrapper) {
                const resizeHandle = wrapper.querySelector('.resize-handle');
                let isDragging = false, isResizing = false;
                let offsetX, offsetY;

                function getCurrentBubbleContainer() {
                    // 获取当前选中的气泡容器
                    const currentType = getCurrentBubbleType();
                    return currentType === 'self' ? previewBubbleSelf : previewBubbleOthers;
                }

                function isCurrentBubbleSticker() {
                    // 检查这个贴纸是否属于当前选中的气泡
                    const currentBubble = getCurrentBubbleContainer();
                    return currentBubble.contains(wrapper);
                }

                function onMoveDown(e) {
                    // 只允许当前选中气泡中的贴纸交互
                    if (!isCurrentBubbleSticker()) {
                        return;
                    }
                    isDragging = true;
                    wrapper.classList.add('dragging');
                    const event = e.touches ? e.touches[0] : e;
                    const rect = wrapper.getBoundingClientRect();
                    const bubbleRect = getCurrentBubbleContainer().getBoundingClientRect();
                    offsetX = event.clientX - rect.left;
                    offsetY = event.clientY - rect.top;
                    document.addEventListener('mousemove', onMove);
                    document.addEventListener('mouseup', onMoveUp);
                    document.addEventListener('touchmove', onMove, { passive: false });
                    document.addEventListener('touchend', onMoveUp);
                }
                function onMove(e) {
                    if (!isDragging) return;
                    e.preventDefault();
                    const event = e.touches ? e.touches[0] : e;
                    const bubbleRect = getCurrentBubbleContainer().getBoundingClientRect();
                    wrapper.style.left = `${event.clientX - bubbleRect.left - offsetX}px`;
                    wrapper.style.top = `${event.clientY - bubbleRect.top - offsetY}px`;
                }
                function onMoveUp() {
                    isDragging = false;
                    wrapper.classList.remove('dragging');
                    document.removeEventListener('mousemove', onMove);
                    document.removeEventListener('mouseup', onMoveUp);
                    document.removeEventListener('touchmove', onMove);
                    document.removeEventListener('touchend', onMoveUp);
                }
                wrapper.addEventListener('mousedown', onMoveDown);
                wrapper.addEventListener('touchstart', onMoveDown, { passive: false });

                function onResizeDown(e) {
                    // 只允许当前选中气泡中的贴纸交互
                    if (!isCurrentBubbleSticker()) {
                        return;
                    }
                    e.stopPropagation();
                    isResizing = true;
                    const event = e.touches ? e.touches[0] : e;
                    const initialWidth = wrapper.offsetWidth;
                    const initialHeight = wrapper.offsetHeight;
                    const initialX = event.clientX;
                    const initialY = event.clientY;

                    function onResizeMove(e) {
                        if (!isResizing) return;
                        const event = e.touches ? e.touches[0] : e;
                        const deltaX = event.clientX - initialX;
                        const deltaY = event.clientY - initialY;
                        const newWidth = Math.max(20, initialWidth + deltaX);
                        const newHeight = Math.max(20, initialHeight + deltaY);
                        wrapper.style.width = `${newWidth}px`;
                        wrapper.style.height = `${newHeight}px`;
                    }

                    function onResizeUp() {
                        isResizing = false;
                        document.removeEventListener('mousemove', onResizeMove);
                        document.removeEventListener('mouseup', onResizeUp);
                        document.removeEventListener('touchmove', onResizeMove);
                        document.removeEventListener('touchend', onResizeUp);
                    }
                    
                    document.addEventListener('mousemove', onResizeMove);
                    document.addEventListener('mouseup', onResizeUp);
                    document.addEventListener('touchmove', onResizeMove, { passive: false });
                    document.addEventListener('touchend', onResizeUp);
                }
                resizeHandle.addEventListener('mousedown', onResizeDown);
                resizeHandle.addEventListener('touchstart', onResizeDown, { passive: false });

                wrapper.addEventListener('dblclick', () => {
                    // 只允许当前选中气泡中的贴纸删除
                    if (!isCurrentBubbleSticker()) {
                        return;
                    }
                    wrapper.remove();
                    showToast('贴图已移除');
                });

                wrapper.addEventListener('click', (e) => {
                    // 只允许当前选中气泡中的贴纸被选择
                    if (!isCurrentBubbleSticker()) {
                        return;
                    }
                    e.stopPropagation();
                    selectSticker(wrapper);
                });
            }

            function selectSticker(wrapper) {
                if (selectedStickerWrapper) {
                    selectedStickerWrapper.classList.remove('selected');
                }
                selectedStickerWrapper = wrapper;
                if (selectedStickerWrapper) {
                    selectedStickerWrapper.classList.add('selected');
                    controls.sendToBackBtn.disabled = false;
                    controls.bringToFrontBtn.disabled = false;
                } else {
                    controls.sendToBackBtn.disabled = true;
                    controls.bringToFrontBtn.disabled = true;
                }
            }
            previewContainer.addEventListener('click', (e) => {
                if (e.target === previewContainer || e.target === previewBubbleSelf || e.target === previewBubbleOthers) {
                    selectSticker(null);
                }
            });

            controls.sendToBackBtn.addEventListener('click', () => {
                if (selectedStickerWrapper) {
                    selectedStickerWrapper.style.zIndex = 1;
                    showToast('已置于文字底层');
                }
            });
            controls.bringToFrontBtn.addEventListener('click', () => {
                if (selectedStickerWrapper) {
                    selectedStickerWrapper.style.zIndex = zIndexCounter++;
                    showToast('已置于文字顶层');
                }
            });


            controls.manageStickersBtn.addEventListener('click', openProcessor);
            controls.closeProcessorBtn.addEventListener('click', closeProcessor);
            controls.galleryStickerUpload.addEventListener('change', handleStickerUpload);
            controls.removeBgBtn.addEventListener('click', () => imageEditorCanvas.classList.add('dropper-cursor'));
            imageEditorCanvas.addEventListener('click', (e) => {
                if (!imageEditorCanvas.classList.contains('dropper-cursor')) return;
                const rect = imageEditorCanvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                const pixel = ctx.getImageData(x, y, 1, 1).data;
                targetColor = [pixel[0], pixel[1], pixel[2]];
                imageEditorCanvas.classList.remove('dropper-cursor');
                processImage(targetColor, controls.tolerance.value);
            });
            controls.tolerance.addEventListener('input', () => {
                controls.toleranceValue.textContent = controls.tolerance.value;
                if (currentEditingStickerId && targetColor) {
                    processImage(targetColor, controls.tolerance.value);
                }
            });
            controls.saveChangesBtn.addEventListener('click', () => {
                const sticker = stickerLibrary.find(s => s.id == currentEditingStickerId);
                if (sticker) {
                    sticker.currentSrc = imageEditorCanvas.toDataURL();
                    saveStickerLibraryToStorage();
                    populateStickerGallery().catch(error => console.error('填充贴图库失败:', error));
                }
            });
            controls.resetStickerBtn.addEventListener('click', () => {
                const sticker = stickerLibrary.find(s => s.id == currentEditingStickerId);
                if (sticker) {
                    sticker.currentSrc = sticker.baseSrc;
                    saveStickerLibraryToStorage();
                    selectStickerForEditing(sticker.id);
                    populateStickerGallery().catch(error => console.error('填充贴图库失败:', error));
                }
            });

            // 【修改】将 textColor 和 fontFamily 添加到事件监听循环中
            ['borderWidth', 'borderColor', 'borderRadius', 'bgColor', 'bgOpacity', 'gradientColor1', 'gradientColor2', 'gradientAngle', 'textColor', 'fontFamily'].forEach(id => { if (controls[id]) { controls[id].addEventListener('input', updateBubbleStyle); } });
            controls.bubbleText.addEventListener('input', () => { 
                const currentTextContent = currentBubbleType === 'self' ? bubbleTextContentSelf : bubbleTextContentOthers;
                currentTextContent.textContent = controls.bubbleText.value; 
            });
            controls.bgTypeSolid.addEventListener('click', () => { currentBgType = 'solid'; controls.solidBgControls.classList.remove('hidden'); controls.gradientBgControls.classList.add('hidden'); controls.bgTypeSolid.classList.add('bg-white', 'text-indigo-600'); controls.bgTypeSolid.classList.remove('text-slate-600'); controls.bgTypeGradient.classList.remove('bg-white', 'text-indigo-600'); controls.bgTypeGradient.classList.add('text-slate-600'); updateBubbleStyle(); });
            controls.bgTypeGradient.addEventListener('click', () => { currentBgType = 'gradient'; controls.solidBgControls.classList.add('hidden'); controls.gradientBgControls.classList.remove('hidden'); controls.bgTypeGradient.classList.add('bg-white', 'text-indigo-600'); controls.bgTypeGradient.classList.remove('text-slate-600'); controls.bgTypeSolid.classList.remove('bg-white', 'text-indigo-600'); controls.bgTypeSolid.classList.add('text-slate-600'); updateBubbleStyle(); });

            // 气泡类型切换事件监听器
            controls.bubbleTypeSelf.addEventListener('click', () => switchBubbleType('self'));
            controls.bubbleTypeOthers.addEventListener('click', () => switchBubbleType('others'));
            
            // CSS样式解析辅助函数
            function extractRgbColor(colorValue) {
                if (!colorValue) return '#ffffff';
                // 如果是rgb/rgba格式，提取RGB部分
                const match = colorValue.match(/rgba?\(([^)]+)\)/);
                if (match) {
                    const values = match[1].split(',').map(v => parseInt(v.trim()));
                    return `#${values.slice(0, 3).map(v => v.toString(16).padStart(2, '0')).join('')}`;
                }
                // 如果已经是hex格式，直接返回
                if (colorValue.startsWith('#')) return colorValue;
                return '#ffffff';
            }

            function extractAlpha(colorValue) {
                if (!colorValue) return 1;
                const match = colorValue.match(/rgba?\([^,]+,[^,]+,[^,]+,?\s*([^)]*)\)/);
                if (match && match[1]) {
                    return parseFloat(match[1]) || 1;
                }
                return 1;
            }

            function extractGradientColors(backgroundValue) {
                if (!backgroundValue || !backgroundValue.includes('gradient')) {
                    return ['#ffffff', '#ffffff'];
                }
                // 匹配gradient中的颜色
                const colorMatches = backgroundValue.match(/(#[0-9a-fA-F]{6}|rgb\([^)]+\)|rgba\([^)]+\))/g);
                if (colorMatches && colorMatches.length >= 2) {
                    return [extractRgbColor(colorMatches[0]), extractRgbColor(colorMatches[1])];
                }
                return ['#ffffff', '#ffffff'];
            }

            function extractGradientAngle(backgroundValue) {
                if (!backgroundValue || !backgroundValue.includes('gradient')) {
                    return 0;
                }
                const angleMatch = backgroundValue.match(/(\d+)deg/);
                return angleMatch ? parseInt(angleMatch[1]) : 0;
            }

            // 为指定气泡类型生成完整配置
            function generateBubbleConfig(bubbleType) {
                const targetBubble = bubbleType === 'self' ? previewBubbleSelf : previewBubbleOthers;
                const targetTextContent = bubbleType === 'self' ? bubbleTextContentSelf : bubbleTextContentOthers;
                const bubbleStyle = window.getComputedStyle(targetBubble);
                const textStyle = window.getComputedStyle(targetTextContent);
                
                // 生成贴纸HTML
                let htmlStickers = '';
                const bubbleWidth = targetBubble.offsetWidth;
                const bubbleHeight = targetBubble.offsetHeight;

                targetBubble.querySelectorAll('.sticker-wrapper').forEach((stickerWrapper, index) => {
                    const stickerImg = stickerWrapper.querySelector('.sticker-image');
                    const stickerId = stickerWrapper.dataset.id;
                    const stickerData = stickerLibrary.find(s => s.id == stickerId);
                    const stickerSrc = stickerImg.src;

                    const leftPx = parseFloat(stickerWrapper.style.left) || 0;
                    const topPx = parseFloat(stickerWrapper.style.top) || 0;
                    const stickerWidth = stickerWrapper.offsetWidth;
                    const stickerHeight = stickerWrapper.offsetHeight;

                    const leftPercent = (leftPx + stickerWidth / 2) / bubbleWidth;
                    const topPercent = (topPx + stickerHeight / 2) / bubbleHeight;
                    
                    let positionStyle = '';
                    if (leftPercent < 0.33 && topPercent < 0.33) {
                        positionStyle = `left: ${leftPx.toFixed(0)}px; top: ${topPx.toFixed(0)}px;`;
                    } else if (leftPercent > 0.67 && topPercent < 0.33) {
                        positionStyle = `right: ${(bubbleWidth - leftPx - stickerWidth).toFixed(0)}px; top: ${topPx.toFixed(0)}px;`;
                    } else if (leftPercent < 0.33 && topPercent > 0.67) {
                        positionStyle = `left: ${leftPx.toFixed(0)}px; bottom: ${(bubbleHeight - topPx - stickerHeight).toFixed(0)}px;`;
                    } else if (leftPercent > 0.67 && topPercent > 0.67) {
                        positionStyle = `right: ${(bubbleWidth - leftPx - stickerWidth).toFixed(0)}px; bottom: ${(bubbleHeight - topPx - stickerHeight).toFixed(0)}px;`;
                    } else {
                        positionStyle = `left: ${((leftPx + stickerWidth / 2) / bubbleWidth * 100).toFixed(1)}%; top: ${((topPx + stickerHeight / 2) / bubbleHeight * 100).toFixed(1)}%; transform: translate(-50%, -50%);`;
                    }
                    
                    htmlStickers += `    <img src="${stickerSrc}" class="sticker-${index}" alt="sticker" style="position: absolute; ${positionStyle} width: ${stickerWidth.toFixed(0)}px; height: ${stickerHeight.toFixed(0)}px; z-index: ${stickerWrapper.style.zIndex || 1}; user-select: none; pointer-events: none;">\\n`;
                });

                const htmlTemplate = `<div class="chat-bubble" style="background: ${bubbleStyle.backgroundColor || bubbleStyle.background}; border: ${bubbleStyle.border}; border-radius: ${bubbleStyle.borderRadius}; padding: 12px; margin-bottom: 8px; max-width: 80%; word-wrap: break-word; position: relative; color: ${textStyle.color}; font-family: ${textStyle.fontFamily};">\\n    {{BUBBLE_TEXT}}\\n${htmlStickers}</div>`;

                return {
                    borderWidth: parseInt(bubbleStyle.borderWidth) || 0,
                    borderColor: bubbleStyle.borderColor || '#000000',
                    borderRadius: parseInt(bubbleStyle.borderRadius) || 0,
                    bgColor: extractRgbColor(bubbleStyle.backgroundColor || '#ffffff'),
                    bgOpacity: extractAlpha(bubbleStyle.backgroundColor || 'rgba(255,255,255,1)'),
                    bgType: bubbleStyle.background.includes('gradient') ? 'gradient' : 'solid',
                    gradientColor1: extractGradientColors(bubbleStyle.background)[0] || '#ffffff',
                    gradientColor2: extractGradientColors(bubbleStyle.background)[1] || '#ffffff',
                    gradientAngle: extractGradientAngle(bubbleStyle.background) || 0,
                    textColor: textStyle.color || '#000000',
                    fontFamily: textStyle.fontFamily || 'system-ui',
                    // bubbleText: 不保存文本内容，每次使用默认值
                    stickers: Array.from(targetBubble.querySelectorAll('.sticker-wrapper')).map(wrapper => ({
                        id: wrapper.dataset.id,
                        left: parseFloat(wrapper.style.left) || 0,
                        top: parseFloat(wrapper.style.top) || 0,
                        width: wrapper.offsetWidth,
                        height: wrapper.offsetHeight,
                        zIndex: wrapper.style.zIndex || 1
                    })),
                    html: htmlTemplate,
                    enabled: true
                };
            }

            controls.generateCodeBtn.addEventListener('click', async () => {
                // 调试：检查数据库连接状态
                console.log('保存按钮点击，数据库状态:', db ? '已连接' : '未连接');
                if (!db) {
                    console.error('数据库连接不可用，尝试重新初始化...');
                    await initStorageSystem();
                    if (!db) {
                        alert('数据库连接失败，无法保存配置');
                        return;
                    }
                }
                
                // 1. 生成当前选择气泡类型的HTML和CSS代码（用于显示）
                const currentBubble = currentBubbleType === 'self' ? previewBubbleSelf : previewBubbleOthers;
                const currentTextContent = currentBubbleType === 'self' ? bubbleTextContentSelf : bubbleTextContentOthers;
                const bubbleStyle = window.getComputedStyle(currentBubble);
                const textStyle = window.getComputedStyle(currentTextContent);
                
                // 【替换开始】
                let htmlStickers = '';
                const bubbleWidth = currentBubble.offsetWidth;
                const bubbleHeight = currentBubble.offsetHeight;

                currentBubble.querySelectorAll('.sticker-wrapper').forEach((stickerWrapper, index) => {
                    const stickerImg = stickerWrapper.querySelector('.sticker-image');
                    const stickerId = stickerWrapper.dataset.id;
                    const stickerData = stickerLibrary.find(s => s.id == stickerId);
                    const stickerSrc = stickerImg.src; // 使用当前显示的URL

                    // --- 全新的定位和尺寸逻辑 ---
                    
                    // 1. 获取贴图的固定像素尺寸和位置
                    const leftPx = parseFloat(stickerWrapper.style.left) || 0;
                    const topPx = parseFloat(stickerWrapper.style.top) || 0;
                    const stickerWidth = stickerWrapper.offsetWidth;
                    const stickerHeight = stickerWrapper.offsetHeight;

                    // 2. 判断贴图在气泡的哪个象限，以决定其定位锚点
                    const leftPercent = (leftPx + stickerWidth / 2) / bubbleWidth;
                    const topPercent = (topPx + stickerHeight / 2) / bubbleHeight;
                    
                    let positionStyle = '';

                    // 如果贴图中心点超过了气泡高度的50%，则使用 bottom 定位
                    if (topPercent > 0.5) {
                        const bottomPx = bubbleHeight - (topPx + stickerHeight);
                        positionStyle += `bottom: ${bottomPx.toFixed(0)}px; `;
                    } else {
                        positionStyle += `top: ${topPx.toFixed(0)}px; `;
                    }

                    // 如果贴图中心点超过了气泡宽度的50%，则使用 right 定位
                    if (leftPercent > 0.5) {
                        const rightPx = bubbleWidth - (leftPx + stickerWidth);
                        positionStyle += `right: ${rightPx.toFixed(0)}px; `;
                    } else {
                        positionStyle += `left: ${leftPx.toFixed(0)}px; `;
                    }
                    
                    // 3. 生成代码：位置用计算出的锚点定位，尺寸用固定的像素值
                    htmlStickers += `    <img src="${stickerSrc}" class="sticker-${index}" alt="sticker" style="position: absolute; ${positionStyle} width: ${stickerWidth.toFixed(0)}px; height: ${stickerHeight.toFixed(0)}px; z-index: ${stickerWrapper.style.zIndex || 1}; user-select: none; pointer-events: none;">\\n`;
                });
                // 【替换结束】

                const htmlTemplate = `<div class="custom-bubble-container" style="position: relative; padding: ${bubbleStyle.padding}; border: ${bubbleStyle.border}; border-radius: ${bubbleStyle.borderRadius}; background: ${bubbleStyle.background};">\\n    <span class="bubble-text" style="position: relative; z-index: 10; color: ${textStyle.color}; font-family: &quot;${textStyle.fontFamily.replace(/"/g, '')}&quot;;">{{BUBBLE_TEXT}}</span>\\n${htmlStickers}</div>`;
                
                // 我们不再需要生成CSS，因为样式已经内联到HTML中了
                const cssCode = `/* CSS 已内联，此部分为空 */`;

                // 2. 将按钮文本改为 "应用此样式"
                controls.generateCodeBtn.textContent = '应用此样式';

                // 3. 收集完整的样式配置
                const completeStyleConfig = {
                    // 基础样式
                    borderWidth: controls.borderWidth.value,
                    borderColor: controls.borderColor.value,
                    borderRadius: controls.borderRadius.value,
                    textColor: controls.textColor.value,
                    fontFamily: controls.fontFamily.value,
                    
                    // 背景样式
                    backgroundType: currentBgType,
                    backgroundColor: controls.bgColor.value,
                    backgroundOpacity: controls.bgOpacity.value,
                    gradientColor1: controls.gradientColor1.value,
                    gradientColor2: controls.gradientColor2.value,
                    gradientAngle: controls.gradientAngle.value,
                                        
                    // 贴图配置
                    stickers: Array.from(currentBubble.querySelectorAll('.sticker-wrapper')).map(wrapper => ({
                        id: wrapper.dataset.id,
                        left: parseFloat(wrapper.style.left) || 0,
                        top: parseFloat(wrapper.style.top) || 0,
                        width: wrapper.offsetWidth,
                        height: wrapper.offsetHeight,
                        zIndex: wrapper.style.zIndex || 1
                    })),
                    
                    // 生成的HTML模板
                    html: htmlTemplate,
                    css: cssCode,
                    
                    // 元数据
                    createdAt: new Date().toISOString(),
                    version: '1.0'
                };

                // 4. 确保启用标志为 true（每次保存都自动启用）
                completeStyleConfig.enabled = true;
                
                // 5. 生成并保存双方气泡的完整配置
                const selfConfig = generateBubbleConfig('self');
                const othersConfig = generateBubbleConfig('others');
                
                // 同时保存双方的配置
                await saveBubbleStyleConfig(selfConfig, 'bubbleStyleSelf');
                await saveBubbleStyleConfig(othersConfig, 'bubbleStyle');

                // 6. 使用 postMessage 发送双方配置给父窗口
                window.parent.postMessage({
                    type: 'apply-bubble-style',
                    payload: {
                        self: selfConfig,
                        others: othersConfig,
                        current: completeStyleConfig // 保留当前选中的配置用于显示
                    },
                    bubbleType: currentBubbleType
                }, '*');

                // 7. 给用户一个反馈
                showToast('已保存双方气泡样式并应用到聊天界面！');
                const originalText = controls.generateCodeBtn.textContent;
                controls.generateCodeBtn.textContent = '✅ 已应用!';
                setTimeout(() => {
                    controls.generateCodeBtn.textContent = originalText;
                }, 2000);
            });

            // 恢复默认气泡样式按钮事件
            controls.resetToDefaultBtn.addEventListener('click', async () => {
                // 显示确认对话框
                if (confirm('确定要恢复默认气泡样式吗？这将删除所有自定义设置。')) {
                    controls.resetToDefaultBtn.textContent = '正在恢复...';
                    controls.resetToDefaultBtn.disabled = true;
                    
                    await resetToDefaultBubbleStyle();
                    
                    // 恢复按钮状态
                    setTimeout(() => {
                        controls.resetToDefaultBtn.textContent = '恢复默认气泡';
                        controls.resetToDefaultBtn.disabled = false;
                    }, 1500);
                }
            });

            // 保存完整的气泡样式配置
            async function saveBubbleStyleConfig(styleConfig, styleKey = 'bubbleStyle') {
                try {
                    if (!db) {
                        console.warn('数据库连接不可用，跳过保存配置');
                        return;
                    }
                    
                    const transaction = db.transaction(['themeConfig'], 'readwrite');
                    const store = transaction.objectStore('themeConfig');
                    
                    // 将 enabled 属性添加到 styleConfig 本身
                    const configData = {
                        type: styleKey,
                        ...styleConfig, // 展开所有样式配置到顶层
                        enabled: true,
                        lastModified: new Date().toISOString()
                    };
                    
                    store.put(configData);
                    
                    transaction.oncomplete = () => {
                        console.log(`${styleKey}配置保存成功`);
                    };
                    
                    transaction.onerror = () => {
                        console.error(`${styleKey}配置保存失败:`, transaction.error);
                    };
                } catch (e) {
                    console.error(`无法保存${styleKey}配置:`, e);
                }
            }

            // 恢复默认气泡样式
            async function resetToDefaultBubbleStyle() {
                try {
                    if (!db) {
                        console.warn('数据库连接不可用，跳过禁用配置');
                        return;
                    }
                    
                    const transaction = db.transaction(['themeConfig'], 'readwrite');
                    const store = transaction.objectStore('themeConfig');
                    
                    // 删除两种气泡样式配置，但保留贴纸库
                    store.delete('bubbleStyle');      // 删除对方气泡配置
                    store.delete('bubbleStyleSelf');  // 删除自己气泡配置
                    
                    transaction.oncomplete = () => {
                        console.log('所有自定义气泡样式配置已删除');
                        
                        // 清理两个气泡容器上的贴纸
                        previewBubbleSelf.querySelectorAll('.sticker-wrapper').forEach(wrapper => wrapper.remove());
                        previewBubbleOthers.querySelectorAll('.sticker-wrapper').forEach(wrapper => wrapper.remove());
                        
                        // 重置所有控件到默认值
                        resetControlsToDefault();
                    };
                    
                    transaction.onerror = () => {
                        console.error('删除气泡样式配置失败:', transaction.error);
                    };
                    
                    // 使用 postMessage 通知父窗口恢复默认样式
                    window.parent.postMessage({
                        type: 'reset-bubble-style'
                    }, '*');
                    
                    showToast('已恢复默认气泡样式！贴纸库保持不变。');
                } catch (e) {
                    console.error("无法恢复默认气泡样式:", e);
                    showToast("恢复默认样式失败");
                }
            }

            // 重置所有控件到默认值
            function resetControlsToDefault() {
                // 重置基础样式控件
                controls.bgColor.value = '#3b82f6';
                controls.textColor.value = '#ffffff';
                controls.borderRadius.value = 18;
                controls.borderWidth.value = 0;
                controls.borderColor.value = '#e2e8f0';
                controls.bgOpacity.value = 1;
                controls.borderOpacity.value = 1;
                
                // 重置渐变相关
                controls.bgType.value = 'solid';
                controls.gradientType.value = 'linear';
                controls.gradientColor1.value = '#3b82f6';
                controls.gradientColor2.value = '#1d4ed8';
                controls.gradientAngle.value = 45;
                
                // 重置文本内容为当前气泡类型的默认值
                const defaultText = currentBubbleType === 'self' ? '这是我发的消息' : '这是对方发的消息';
                controls.bubbleText.value = defaultText;
                
                // 同时更新预览显示
                const currentTextContent = currentBubbleType === 'self' ? bubbleTextContentSelf : bubbleTextContentOthers;
                currentTextContent.textContent = defaultText;
                
                // 更新显示值
                updateValueDisplays();
                
                // 重新应用样式到预览气泡
                updateBubblePreview();
                
                console.log('所有控件已重置到默认值');
            }

            // 加载完整的气泡样式配置
            async function loadBubbleStyleConfig(styleKey = 'bubbleStyle') {
                try {
                    if (!db) {
                        console.warn('数据库连接不可用，跳过加载配置');
                        return null;
                    }
                    
                    return new Promise((resolve) => {
                        const transaction = db.transaction(['themeConfig'], 'readonly');
                        const store = transaction.objectStore('themeConfig');
                        const request = store.get(styleKey);
                        
                        request.onsuccess = () => {
                            const result = request.result;
                            if (result) {
                                console.log(`${styleKey}配置加载成功`);
                                // 移除 type 和系统字段，返回样式配置
                                const { type, lastModified, ...styleConfig } = result;
                                resolve(styleConfig);
                            } else {
                                console.log(`未找到已保存的${styleKey}配置`);
                                resolve(null);
                            }
                        };
                        
                        request.onerror = () => {
                            console.error(`加载${styleKey}配置失败:`, request.error);
                            resolve(null);
                        };
                    });
                } catch (e) {
                    console.error(`无法加载${styleKey}配置:`, e);
                    return null;
                }
            }

            // 应用保存的配置到界面
            async function applyBubbleStyleConfig(config) {
                if (!config) return;
                
                try {
                    // 应用基础样式
                    controls.borderWidth.value = config.borderWidth || 1;
                    controls.borderColor.value = config.borderColor || '#4f46e5';
                    controls.borderRadius.value = config.borderRadius || 12;
                    controls.textColor.value = config.textColor || '#333333';
                    controls.fontFamily.value = config.fontFamily || 'Inter';
                    
                    // 应用背景样式
                    currentBgType = config.backgroundType || 'solid';
                    controls.bgColor.value = config.backgroundColor || '#ffffff';
                    controls.bgOpacity.value = config.backgroundOpacity || 1;
                    controls.gradientColor1.value = config.gradientColor1 || '#a5b4fc';
                    controls.gradientColor2.value = config.gradientColor2 || '#e0e7ff';
                    controls.gradientAngle.value = config.gradientAngle || 145;
                    
                    // 切换背景类型
                    if (currentBgType === 'gradient') {
                        controls.bgTypeGradient.click();
                    } else {
                        controls.bgTypeSolid.click();
                    }
                    
                    // 文本内容始终使用默认值，不从配置中应用
                    const defaultText = currentBubbleType === 'self' ? '这是我发的消息' : '这是对方发的消息';
                    controls.bubbleText.value = defaultText;
                    const currentTextContent = currentBubbleType === 'self' ? bubbleTextContentSelf : bubbleTextContentOthers;
                    currentTextContent.textContent = defaultText;
                    
                    // 恢复贴图（不在这里处理，在初始化函数中处理）
                    // if (config.stickers && config.stickers.length > 0) {
                    //     await restoreStickers(config.stickers, currentBubbleType);
                    // }
                    
                    // 更新样式
                    updateBubbleStyle();
                    
                    console.log('气泡样式配置已应用到界面');
                } catch (error) {
                    console.error('应用气泡样式配置失败:', error);
                }
            }

            // 恢复贴图
            async function restoreStickers(stickerConfigs, targetBubbleType = 'others') {
                // 清除对应气泡的现有贴图
                const targetBubble = targetBubbleType === 'self' ? previewBubbleSelf : previewBubbleOthers;
                targetBubble.querySelectorAll('.sticker-wrapper').forEach(wrapper => wrapper.remove());
                
                for (const stickerConfig of stickerConfigs) {
                    const stickerData = stickerLibrary.find(s => s.id === stickerConfig.id);
                    if (!stickerData) {
                        console.warn('找不到贴图数据:', stickerConfig.id);
                        continue;
                    }
                    
                    // 创建贴图元素
                    const wrapper = document.createElement('div');
                    wrapper.className = 'sticker-wrapper';
                    wrapper.dataset.id = stickerData.id;
                    wrapper.style.zIndex = stickerConfig.zIndex;
                    wrapper.style.left = stickerConfig.left + 'px';
                    wrapper.style.top = stickerConfig.top + 'px';
                    wrapper.style.width = stickerConfig.width + 'px';
                    wrapper.style.height = stickerConfig.height + 'px';
                    
                    const newSticker = document.createElement('img');
                    newSticker.className = 'sticker-image';
                    
                    // 获取图片URL
                    const imageUrl = await getStickerImageURL(stickerData);
                    if (imageUrl) {
                        newSticker.src = imageUrl;
                    }
                    
                    const resizeHandle = document.createElement('div');
                    resizeHandle.className = 'resize-handle';
                    
                    wrapper.appendChild(newSticker);
                    wrapper.appendChild(resizeHandle);
                    targetBubble.appendChild(wrapper);
                    
                    makePlacedStickerInteractive(wrapper);
                }
                
                // 恢复贴纸后更新交互状态
                updateStickersInteractionState();
            }

            // 异步初始化
            async function initializeApp() {
                await initStorageSystem();
                await loadStickerLibraryFromStorage();
                await renderStickerLibrary();
                
                // 加载并应用保存的配置（两种气泡样式）
                const savedSelfConfig = await loadBubbleStyleConfig('bubbleStyleSelf');
                const savedOthersConfig = await loadBubbleStyleConfig('bubbleStyle');
                
                if (savedSelfConfig) {
                    // 切换到自己模式并应用配置
                    currentBubbleType = 'self';
                    await applyBubbleStyleConfig(savedSelfConfig);
                    
                    // 恢复自己的贴图
                    if (savedSelfConfig.stickers && savedSelfConfig.stickers.length > 0) {
                        await restoreStickers(savedSelfConfig.stickers, 'self');
                    }
                }
                
                if (savedOthersConfig) {
                    // 切换到别人模式并应用配置
                    currentBubbleType = 'others';
                    await applyBubbleStyleConfig(savedOthersConfig);
                    
                    // 恢复别人的贴图
                    if (savedOthersConfig.stickers && savedOthersConfig.stickers.length > 0) {
                        await restoreStickers(savedOthersConfig.stickers, 'others');
                    }
                }
                
                // 默认切换到自己的气泡编辑模式
                switchBubbleType('self');
                
                // 如果没有保存的配置，应用默认样式
                if (!savedSelfConfig && !savedOthersConfig) {
                    updateBubbleStyle();
                }
            }
            
            initializeApp();
        });
    </script>
</body>
</html>